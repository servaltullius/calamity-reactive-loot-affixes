using System.Globalization;
using System.Text;
using CalamityAffixes.Generator.Spec;

namespace CalamityAffixes.Generator.Writers;

public static class KidIniWriter
{
    public static string Render(AffixSpec spec)
    {
        var sb = new StringBuilder();

        sb.AppendLine("; CalamityAffixes_KID.ini (AUTOGENERATED)");
        sb.AppendLine($"; Generated: {DateTimeOffset.UtcNow:O}");
        sb.AppendLine("; NOTE: filename must end with \"_KID.ini\" and live in Skyrim's Data folder.");
        sb.AppendLine("; DO NOT EDIT BY HAND. Edit affixes/modules/*.json (or affixes/affixes.json) and re-run generator.");
        sb.AppendLine("; Format (KID v3): Keyword = KeywordEditorId|Type|Filters|Traits|Chance");
        sb.AppendLine();
        sb.AppendLine("; Instance mode: affix keywords are NOT distributed via KID.");
        sb.AppendLine("; (Affixes are rolled per item instance at runtime by the SKSE plugin.)");
        sb.AppendLine();

        foreach (var rule in spec.Keywords.KidRules)
        {
            if (!string.IsNullOrWhiteSpace(rule.Comment))
            {
                sb.AppendLine();
                sb.AppendLine($"; {rule.Comment}");
            }

            var type = rule.Type.Trim();
            var filters = MergeFilters(rule.Strings, rule.FormFilters);

            // Safety: a Magic Effect rule with no filters will tag *every* MGEF in the load order.
            // This is extremely risky (e.g., can unintentionally affect keyword-based dispels).
            // Skip rendering this rule entirely.
            if (string.Equals(type, "Magic Effect", StringComparison.OrdinalIgnoreCase) &&
                string.Equals(filters, "NONE", StringComparison.OrdinalIgnoreCase))
            {
                sb.AppendLine("; WARNING: Skipped unsafe KID rule (Magic Effect with no filters would tag ALL magic effects).");
                continue;
            }

            sb.Append("Keyword = ");
            sb.Append(rule.KeywordEditorId);
            sb.Append('|');
            sb.Append(type);
            sb.Append('|');
            sb.Append(filters);
            sb.Append('|');
            sb.Append(rule.Traits.Trim());
            sb.Append('|');
            sb.AppendLine(FormatChance(rule.Chance));
        }

        return sb.ToString();
    }

    private static string MergeFilters(string? strings, string? formFilters)
    {
        var stringsValue = NormalizeNone(strings);
        var formFiltersValue = NormalizeNone(formFilters);

        if (stringsValue is null && formFiltersValue is null)
        {
            return "NONE";
        }

        if (stringsValue is null)
        {
            return formFiltersValue!;
        }

        if (formFiltersValue is null)
        {
            return stringsValue;
        }

        return $"{stringsValue},{formFiltersValue}";
    }

    private static string? NormalizeNone(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return null;
        }

        var trimmed = value.Trim();
        return string.Equals(trimmed, "NONE", StringComparison.OrdinalIgnoreCase) ? null : trimmed;
    }

    private static string FormatChance(double value)
    {
        if (Math.Abs(value - Math.Round(value)) < 0.0000001)
        {
            return ((int)Math.Round(value)).ToString(CultureInfo.InvariantCulture);
        }

        return value.ToString("0.###", CultureInfo.InvariantCulture);
    }
}
